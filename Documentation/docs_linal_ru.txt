Документация "библиотеки" linal.h

В ней реализованы следующие классы:
* Matrix
* Vector
* Dekart_System

Подробнее про каждый класс:

Класс, реализующий матрицы.
* Matrix:
	Зависит от: iostream, std::cout
	От него зависят: Vector, Dekart_System

	Поля (переменные):
		* double** data --- двумерный массив с элементами матрицы
		* unsigned int height --- высота (количество строк)
		* unsigned int width --- ширина (количество столбцов)

	Методы:
		* clear() --- Заполнить матрицу нулями
		* getHeight() --- Получить высоту (так как переменная приватная)
		* getWidth() --- Получить ширину (так как переменная приватная)
		* getElement(unsigned int vert_ind, unsigned int horis_ind) --- Получить элемент строки "vert_ind" и столбца "horis_ind"
		* getElements() --- Получить все элементы матрицы в виде массива double* (массив линейный, т.е матрица преобразуется в одну строку)
		* getData() --- Получить все элементы матрицы в исходном виде, т.е в виде двумерного массива double**
		* changeElement(unsigned int vert_ind, unsigned int horis_ind) --- Изменить элемент строки "vert_ind" и столбца "horis_ind"
		* multiplyToNum(double) --- Умножить все элементы матрицы на число
		* divideToNum(double) --- Поделить все элементы матрицы на число
		* transpose() --- Транспонировать матрицу
		* getTranspositioned() --- Получить транспонированную матрицу
		* getMinor(unsigned int vert_ind, unsigned int horis_ind) --- Получить минорную матрицу (т.е матрицу, полученную вычеркивание строки "vert_ind" и столбца "horis_ind" из исходной матрицы)
		* getDeterminant() --- Получить детерминант
		* getAdjugated() --- Получить союзную матрицу, т.е матрицу составленную из алгебраических дополнений исходной матрицы (и транспонированной после)
		* invert() --- Инвертировать матрицу, т.е превратить в обратную исходной
		* getInverted() --- Получить обратную матрицу
		* print() --- Вывести на экран консоли матрицу в привычном виде (часто выводит не особо хорошо, но вполне достаточно для отладки)
		* fill(double value) --- Заполнить матрицу значением "value"
		* static sum(Matrix*, Matrix*) --- Получить сумму двух матриц
		* static subtract(Matrix*, Matrix*) --- Получить разность двух матриц
		* static multiply(Matrix*, Matrix*) --- Получить произведение двух матриц

Класс, реализующий вектора.
Двоеточие означает, что Vector наследует Matrix
* Vector : Matrix:
	Зависит от: iostream, std::cout, Matrix
	От него зависят: Dekart_System

	Поля (переменные):
		* unsigned int dimension --- Измерение, т.е количество строк (столбец у вектора всегда один)

	Методы:
		* getDimension() --- Получить измерение
		* static sum(Vector*, Vector*) --- Получить сумму двух векторов
		* static scalar_multiply(Vector*, Vector*) --- Получить скалярное произведение двух векторов (ВЫЧИСЛЯЕТ ТОЛЬКО В ПДСК)
		* static vector_multiply(Vector*, Vector*) --- Получить векторное произведение двух векторов (ВЫЧИСЛЯЕТ ТОЛЬКО В ПДСК И РАБОТАЕТ ТОЛЬКО С 3-МЕРНЫМИ ВЕКТОРАМИ)

Класс, реализующий ПДСК в трёхмерном пространстве.
! ВСЕ ВЕКТОРА В ЭТОМ КЛАССЕ - ЖЕСТКО ТРЕХМЕРНЫЕ !
* Dekart_System:
	Зависит от: iostream, std::cout, Matrix, Vector
	От него зависят: NONE

	Поля (переменные):
		* Vector* Base_dot --- Радиус-вектор точки начала координат (задается в некой "абсолютной" системе координат, например связанной с верхним левым углом монитора компьютера)
		* Vector** Basis --- Базис - массив векторов, количество равно измерению.

	functions:
		* print() --- Вывести на экран консоли матрицы векторов "Base_dot" и "Basis"
		* getTransformationMatrix(Dekart_System*) --- Получить матрицу перехода (Выражает СТАРЫЕ координаты через НОВЫЕ)
		* getTransformationMatrix_native(Dekart_System*) --- Получить обратную матрицу перехода (Выражает НОВЫЕ координаты через СТАРЫЕ)
		* switchSystem(Dekart_System*, Vector** vectors, unsigned int v_length) --- Заменить ПДСК  на новую и поменять координаты всех связанных "vectors", количеством "length"
